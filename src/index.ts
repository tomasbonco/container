import 'reflect-metadata';

/**
 * This is container manager inspirated by Aurelia's one. It works like a context, where all instances are
 * registred as singletons. Then it resolves dependecies and passes singletons to constructor.
 * 
 * If you want to use it, just use @autoinject decorator on the class and inside constructor specify what
 * dependencies you want to use. Or in case you use Javascript set dependencies as static `__inject` field:
 * 
 * ```
 * class MyClass
 * {
 * 		static __inject = [ MyOtherClass, SecondDependency ];
 * }
 * ```
 */

export class Container
{
	static instance: Container = undefined;

	private instances: Map<any, any> = new Map<any, any>();
	private parent: Container;


	constructor()
	{
		this.set( Container, this );
	}
	

	/**
	 * Returns existing or a new instance of provided class and saves it into list of singletons.
	 * 
	 * @param {any} key - class-like object (constructor) to make instance of
	 * @returns {any} - instance of class provided
	 */
	get( key: any ): any
	{
		// Find instance in instance-map
		
		const resolver: Resolver = ( key instanceof Resolver ) ? key : Singleton.of( key );
		let instance: any = resolver.resolve( this );


		// Create a new instance, if we haven't found one

		if ( ! instance )
		{
			instance = this.createInstance( key );
			this.instances.set( key, instance );
		}

		return instance;
	}


	/**
	 * Adds instance into list of singletons.
	 * 
	 * @param {any} key - constructor
	 * @param {any} value - instance 
	 */
	set( key: any, value: any ): any
	{
		this.instances.set( key, value );
		return value;
	}


	/**
	 * Returns true if for given constructor there is singleton defined under this container.
	 * 
	 * @param {any} key - constructor
	 * @returns {boolean} - true if singleton is set
	 */
	has( key: any ): boolean
	{
		return this.instances.has( key );
	}


	/**
	 * Removes singleton of given constructor from container.
	 * 
	 * @param {any} key - constructor 
	 */
	drop( key: any ): boolean
	{
		return this.instances.delete( key );
	}


	/**
	 * Returns instance of given constructor defined under this container, if there is any.
	 * 
	 * @param {any} key - constructor
	 */
	getInstance( key: any ): any
	{
		return this.instances.get( key );
	}


	/**
	 * Set this container as root. It will be available via static `Container.instance`.
	 */
	setRoot(): void
	{
		Container.instance = this;
	}


	/**
	 * Returns true, if current container is root.
	 * 
	 * @returns {boolean} - true, if current container is root.
	 */
	isRoot(): boolean
	{
		return this === Container.instance;
	}


	/**
	 * Set parent to this container.
	 * Right now it is not used in resolving. But it is still useful, if you are creating smaller containers from master container.
	 * 
	 * @param {Container} parentContainer - parent
	 */
	setParent( parentContainer: Container ): void
	{
		this.parent = parentContainer;
	}


	/**
	 * Returns parent of current container.
	 * 
	 * @returns {Container} - parent
	 */
	getParent(): Container
	{
		return this.parent;
	}


	/**
	 * Returns instance of target, with dependecies resolved, but won't add it into list of singletons.
	 * 
	 * @param {any} target - Class-like object (constructor) to make instance of
	 * @returns {any} - instance
	 */
	createInstance( target: any ): any
	{
		let instance: any;

		if ( typeof target !== 'function')
		{
			console.log( target );
			throw new Error( 'Container cannot make instance of non-function!' );
		}

		try
		{
			let dependencies: any[] = [];

			if ( target.__inject && Array.isArray( target.__inject ) )
			{
				dependencies = target.__inject.map( x => this.get( x ) );
			}

			instance = new target( ...dependencies );
		}

		catch ( e )
		{
			if ( e instanceof TypeError )
			{
				throw e;
			}

			console.log( e );
		}

		return instance;
	}


	destruct()
	{
		this.instances.forEach( instance => instance.teardown ? instance.teardown() : undefined )
	}
}

export function inject( ...dependecies: any[] ): ( target: any ) => void
{
	return function( target: any ): void
	{
		target.__inject = dependecies;
	}
}


export function autoinject( potentialTarget?: any ): any
{
	const deco = function( target )
	{
		const deps = Reflect['getOwnMetadata']( 'design:paramtypes', target ) || {}; // generated by TypeScript
		target.__inject = deps;
	}

	return potentialTarget ? deco( potentialTarget ) : deco;
}


class Resolver
{
	constructor()
	{}

	resolve( container: Container ): any
	{}
}


export class Instance extends Resolver
{
	constructor( public key: any )
	{
		super();
	}


	static of( key: any ): Instance
	{
		return new Instance( key );
	}

	resolve( container: Container ): any
	{
		return container.createInstance( this.key ); 
	}
}


export class Singleton extends Resolver
{
	constructor( public key: any )
	{
		super();
	}


	static of( key: any ): Singleton
	{
		return new Singleton( key );
	}


	resolve( container: Container ): any
	{
		return container.getInstance( this.key );
	}
}


export class Parent extends Resolver
{
	constructor( public key: any )
	{
		super();
	}


	static of( key: any ): Parent
	{
		return new Parent( key );
	}

	resolve( container: Container ): any
	{
		const parent: Container = container.getParent();

		if ( ! parent )
		{
			throw new Error( `Parent container not specified!` );
		}

		return parent.get( this.key );
	}
}